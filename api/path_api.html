<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matplotlib.path &mdash; Matplotlib 3.1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.1.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html"
/>
    <link rel="search" title="Search" href="../search.html"
/>
    <link rel="top" title="Matplotlib 3.1.1 documentation" href="../index.html" />
    <link rel="up" title="API Overview" href="index.html" />
    <link rel="next" title="matplotlib.patheffects" href="patheffects_api.html" />
    <link rel="prev" title="matplotlib.patches.draw_bbox" href="_as_gen/matplotlib.patches.draw_bbox.html" />
    <link rel="canonical" href="https://matplotlib.org/3.1.1/api/path_api.html" />



  </head>
  <body>



<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.1.1</span></div>
    <img src="../_static/logo2.png" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="patheffects_api.html" title="matplotlib.patheffects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="_as_gen/matplotlib.patches.draw_bbox.html" title="matplotlib.patches.draw_bbox"
             accesskey="P">previous</a> |</li>

        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../tutorials/index.html">tutorials</a>|&nbsp;</li>
        <li><a href="index.html">API</a>|&nbsp;</li>
        <li><a href="../contents.html">contents</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API Overview</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">API Overview</a><ul>
      <li>Previous: <a href="_as_gen/matplotlib.patches.draw_bbox.html" title="previous chapter">matplotlib.patches.draw_bbox</a></li>
      <li>Next: <a href="patheffects_api.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">matplotlib.patheffects</span></code></a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div id="sidebar-pagesource" role="note" aria-label="source link"
    style="margin-top: 1.5em; padding-top: 0.1em; border-top: 1px solid #86989b">
  <a href="../_sources/api/path_api.rst.txt"
     style="color: #c0c0c0" rel="nofollow">Show Page Source</a>
  </div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-matplotlib.path">
<span id="matplotlib-path"></span><h1><code class="docutils literal notranslate"><span class="pre">matplotlib.path</span></code><a class="headerlink" href="#module-matplotlib.path" title="Permalink to this headline">¶</a></h1>
<p>A module for dealing with the polylines used throughout Matplotlib.</p>
<p>The primary class for polyline handling in Matplotlib is <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>.  Almost all
vector drawing makes use of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>s somewhere in the drawing pipeline.</p>
<p>Whilst a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> instance itself cannot be drawn, some <a class="reference internal" href="artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Artist</span></code></a> subclasses,
such as <a class="reference internal" href="_as_gen/matplotlib.patches.PathPatch.html#matplotlib.patches.PathPatch" title="matplotlib.patches.PathPatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PathPatch</span></code></a> and <a class="reference internal" href="collections_api.html#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PathCollection</span></code></a>, can be used for convenient <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>
visualisation.</p>
<dl class="class">
<dt id="matplotlib.path.Path">
<em class="property">class </em><code class="descclassname">matplotlib.path.</code><code class="descname">Path</code><span class="sig-paren">(</span><em>vertices</em>, <em>codes=None</em>, <em>_interpolation_steps=1</em>, <em>closed=False</em>, <em>readonly=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> represents a series of possibly disconnected,
possibly closed, line and curve segments.</p>
<dl class="docutils">
<dt>The underlying storage is made up of two parallel numpy arrays:</dt>
<dd><ul class="first last simple">
<li><em>vertices</em>: an Nx2 float array of vertices</li>
<li><em>codes</em>: an N-length uint8 array of vertex types</li>
</ul>
</dd>
</dl>
<p>These two arrays always have the same length in the first
dimension.  For example, to represent a cubic curve, you must
provide three vertices as well as three codes <code class="docutils literal notranslate"><span class="pre">CURVE3</span></code>.</p>
<p>The code types are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">STOP</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex (ignored)</span></dt>
<dd>A marker for the end of the entire path (currently not
required and ignored)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">MOVETO</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex</span></dt>
<dd>Pick up the pen and move to the given vertex.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">LINETO</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex</span></dt>
<dd>Draw a line from the current position to the given vertex.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CURVE3</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">1 control point, 1 endpoint</span></dt>
<dd>Draw a quadratic Bezier curve from the current position,
with the given control point, to the given end point.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CURVE4</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">2 control points, 1 endpoint</span></dt>
<dd>Draw a cubic Bezier curve from the current position, with
the given control points, to the given end point.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">CLOSEPOLY</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex (ignored)</span></dt>
<dd>Draw a line segment to the start point of the current
polyline.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Users of Path objects should not access the vertices and codes
arrays directly.  Instead, they should use <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_segments()</span></code></a>
or <a class="reference internal" href="#matplotlib.path.Path.cleaned" title="matplotlib.path.Path.cleaned"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cleaned()</span></code></a> to get the vertex/code pairs.  This is important,
since many <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> objects, as an optimization, do not store a
<em>codes</em> at all, but have a default one provided for them by
<a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_segments()</span></code></a>.</p>
<p>Some behavior of Path objects can be controlled by rcParams. See
the rcParams whose keys contain 'path.'.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The vertices and codes arrays should be treated as
immutable -- there are a number of optimizations and assumptions
made up front in the constructor that will not change when the
data changes.</p>
</div>
<p>Create a new path with the given vertices and codes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first">The <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2)</span></code> float array, masked array or sequence of pairs
representing the vertices of the path.</p>
<p class="last">If <em>vertices</em> contains masked values, they will be converted
to NaNs which are then handled correctly by the Agg
PathIterator and other consumers of path data, such as
<a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_segments()</span></code></a>.</p>
</dd>
<dt><strong>codes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, array_like}, optional</span></dt>
<dd><p class="first last">n-length array integers representing the codes of the path.
If not None, codes must be the same length as vertices.
If None, <em>vertices</em> will be treated as a series of line segments.</p>
</dd>
<dt><strong>_interpolation_steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Used as a hint to certain projections, such as Polar, that this
path should be linearly interpolated immediately before drawing.
This attribute is primarily an implementation detail and is not
intended for public use.</p>
</dd>
<dt><strong>closed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If <em>codes</em> is None and closed is True, vertices will be treated as
line segments of a closed polygon.</p>
</dd>
<dt><strong>readonly</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Makes the path behave in an immutable way and sets the vertices
and codes as read-only arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="matplotlib.path.Path.CLOSEPOLY">
<code class="descname">CLOSEPOLY</code><em class="property"> = 79</em><a class="headerlink" href="#matplotlib.path.Path.CLOSEPOLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.CURVE3">
<code class="descname">CURVE3</code><em class="property"> = 3</em><a class="headerlink" href="#matplotlib.path.Path.CURVE3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.CURVE4">
<code class="descname">CURVE4</code><em class="property"> = 4</em><a class="headerlink" href="#matplotlib.path.Path.CURVE4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.LINETO">
<code class="descname">LINETO</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.path.Path.LINETO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.MOVETO">
<code class="descname">MOVETO</code><em class="property"> = 1</em><a class="headerlink" href="#matplotlib.path.Path.MOVETO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.NUM_VERTICES_FOR_CODE">
<code class="descname">NUM_VERTICES_FOR_CODE</code><em class="property"> = {0: 1, 1: 1, 2: 1, 3: 2, 4: 3, 79: 1}</em><a class="headerlink" href="#matplotlib.path.Path.NUM_VERTICES_FOR_CODE" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping Path codes to the number of vertices that the
code expects.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.STOP">
<code class="descname">STOP</code><em class="property"> = 0</em><a class="headerlink" href="#matplotlib.path.Path.STOP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.arc">
<em class="property">classmethod </em><code class="descname">arc</code><span class="sig-paren">(</span><em>theta1</em>, <em>theta2</em>, <em>n=None</em>, <em>is_wedge=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.arc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit circle arc from angles <em>theta1</em> to <em>theta2</em> (in
degrees).</p>
<p><em>theta2</em> is unwrapped to produce the shortest arc within 360 degrees.
That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the arc will be from <em>theta1</em> to
<em>theta2</em> - 360 and not a full circle plus some extra overlap.</p>
<p>If <em>n</em> is provided, it is the number of spline segments to make.
If <em>n</em> is not provided, the number of spline segments is
determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>
<blockquote>
<div>Masionobe, L.  2003.  <a class="reference external" href="http://www.spaceroots.org/documents/ellipse/index.html">Drawing an elliptical arc using
polylines, quadratic or cubic Bezier curves</a>.</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.circle">
<em class="property">classmethod </em><code class="descname">circle</code><span class="sig-paren">(</span><em>center=(0.0</em>, <em>0.0)</em>, <em>radius=1.0</em>, <em>readonly=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.circle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> representing a circle of a given radius and center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pair of floats</span></dt>
<dd><p class="first last">The center of the circle. Default <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>.</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The radius of the circle. Default is 1.</p>
</dd>
<dt><strong>readonly</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the created path should have the &quot;readonly&quot; argument
set when creating the Path instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The circle is approximated using 8 cubic Bezier curves, as described in</p>
<blockquote>
<div>Lancaster, Don.  <a class="reference external" href="http://www.tinaja.com/glib/ellipse4.pdf">Approximating a Circle or an Ellipse Using Four
Bezier Cubic Splines</a>.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.cleaned">
<code class="descname">cleaned</code><span class="sig-paren">(</span><em>self</em>, <em>transform=None</em>, <em>remove_nans=False</em>, <em>clip=None</em>, <em>quantize=False</em>, <em>simplify=False</em>, <em>curves=False</em>, <em>stroke_width=1.0</em>, <em>snap=False</em>, <em>sketch=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.cleaned"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.cleaned" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Path with vertices and codes cleaned according to the
parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path.iter_segments</span></code></a></dt>
<dd>for details of the keyword arguments.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.clip_to_bbox">
<code class="descname">clip_to_bbox</code><span class="sig-paren">(</span><em>self</em>, <em>bbox</em>, <em>inside=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.clip_to_bbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.clip_to_bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip the path to the given bounding box.</p>
<p>The path must be made up of one or more closed polygons.  This
algorithm will not behave correctly for unclosed paths.</p>
<p>If <em>inside</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a>, clip to the inside of the box, otherwise
to the outside of the box.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.code_type">
<code class="descname">code_type</code><a class="headerlink" href="#matplotlib.path.Path.code_type" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint8</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.codes">
<code class="descname">codes</code><a class="headerlink" href="#matplotlib.path.Path.codes" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of codes in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> as a 1-D numpy array.  Each
code is one of <a class="reference internal" href="#matplotlib.path.Path.STOP" title="matplotlib.path.Path.STOP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">STOP</span></code></a>, <a class="reference internal" href="#matplotlib.path.Path.MOVETO" title="matplotlib.path.Path.MOVETO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MOVETO</span></code></a>, <a class="reference internal" href="#matplotlib.path.Path.LINETO" title="matplotlib.path.Path.LINETO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LINETO</span></code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CURVE3</span></code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CURVE4</span></code></a>
or <a class="reference internal" href="#matplotlib.path.Path.CLOSEPOLY" title="matplotlib.path.Path.CLOSEPOLY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CLOSEPOLY</span></code></a>.  For codes that correspond to more than one
vertex (<a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CURVE3</span></code></a> and <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CURVE4</span></code></a>), that code will be repeated so
that the length of <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.vertices</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.codes</span></code> is always
the same.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.contains_path">
<code class="descname">contains_path</code><span class="sig-paren">(</span><em>self</em>, <em>path</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.contains_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.contains_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this (closed) path completely contains the given path.</p>
<p>If <em>transform</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the path will be transformed before
performing the test.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.contains_point">
<code class="descname">contains_point</code><span class="sig-paren">(</span><em>self</em>, <em>point</em>, <em>transform=None</em>, <em>radius=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.contains_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.contains_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the (closed) path contains the given point.</p>
<p>If <em>transform</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the path will be transformed before
performing the test.</p>
<p><em>radius</em> allows the path to be made slightly larger or smaller.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.contains_points">
<code class="descname">contains_points</code><span class="sig-paren">(</span><em>self</em>, <em>points</em>, <em>transform=None</em>, <em>radius=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.contains_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.contains_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array which is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the (closed) path contains
the corresponding point.</p>
<p>If <em>transform</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the path will be transformed before
performing the test.</p>
<p><em>radius</em> allows the path to be made slightly larger or smaller.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.path.Path.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a shallow copy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>, which will share the
vertices and codes with the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>self</em>, <em>memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.path.Path.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deepcopy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>.  The <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> will not be
readonly, even if the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> is.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.get_extents">
<code class="descname">get_extents</code><span class="sig-paren">(</span><em>self</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.get_extents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.get_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the extents (<em>xmin</em>, <em>ymin</em>, <em>xmax</em>, <em>ymax</em>) of the
path.</p>
<p>Unlike computing the extents on the <em>vertices</em> alone, this
algorithm will take into account the curves and deal with
control points appropriately.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.has_nonfinite">
<code class="descname">has_nonfinite</code><a class="headerlink" href="#matplotlib.path.Path.has_nonfinite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.hatch">
<code class="descname">hatch</code><span class="sig-paren">(</span><em>hatchpattern</em>, <em>density=6</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.hatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a hatch specifier, <em>hatchpattern</em>, generates a Path that
can be used in a repeated hatching pattern.  <em>density</em> is the
number of lines per unit square.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.interpolated">
<code class="descname">interpolated</code><span class="sig-paren">(</span><em>self</em>, <em>steps</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.interpolated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.interpolated" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new path resampled to length N x steps.  Does not
currently handle interpolating curves.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.intersects_bbox">
<code class="descname">intersects_bbox</code><span class="sig-paren">(</span><em>self</em>, <em>bbox</em>, <em>filled=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.intersects_bbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.intersects_bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if this path intersects a given
<a class="reference internal" href="transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</p>
<p><em>filled</em>, when True, treats the path as if it was filled.
That is, if the path completely encloses the bounding box,
<a class="reference internal" href="#matplotlib.path.Path.intersects_bbox" title="matplotlib.path.Path.intersects_bbox"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersects_bbox()</span></code></a> will return True.</p>
<p>The bounding box is always considered filled.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.intersects_path">
<code class="descname">intersects_path</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>filled=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.intersects_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.intersects_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if this path intersects another given path.</p>
<p><em>filled</em>, when True, treats the paths as if they were filled.
That is, if one path completely encloses the other,
<a class="reference internal" href="#matplotlib.path.Path.intersects_path" title="matplotlib.path.Path.intersects_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersects_path()</span></code></a> will return True.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.iter_segments">
<code class="descname">iter_segments</code><span class="sig-paren">(</span><em>self</em>, <em>transform=None</em>, <em>remove_nans=True</em>, <em>clip=None</em>, <em>snap=False</em>, <em>stroke_width=1.0</em>, <em>simplify=None</em>, <em>curves=True</em>, <em>sketch=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.iter_segments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.iter_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all of the curve segments in the path.  Each iteration
returns a 2-tuple <code class="docutils literal notranslate"><span class="pre">(vertices,</span> <span class="pre">code)</span></code>, where <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is a
sequence of 1-3 coordinate pairs, and <code class="docutils literal notranslate"><span class="pre">code</span></code> is a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> code.</p>
<p>Additionally, this method can provide a number of standard cleanups and
conversions to the path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or <a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></span></dt>
<dd><p class="first last">If not None, the given affine transformation will be applied to the
path.</p>
</dd>
<dt><strong>remove_nans</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to remove all NaNs from the path and skip over them using
MOVETO commands.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or (float, float, float, float), optional</span></dt>
<dd><p class="first last">If not None, must be a four-tuple (x1, y1, x2, y2)
defining a rectangle in which to clip the path.</p>
</dd>
<dt><strong>snap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or bool, optional</span></dt>
<dd><p class="first last">If True, snap all nodes to pixels; if False, don't snap them.
If None, perform snapping if the path contains only segments
parallel to the x or y axes, and no more than 1024 of them.</p>
</dd>
<dt><strong>stroke_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The width of the stroke being drawn (used for path snapping).</p>
</dd>
<dt><strong>simplify</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or bool, optional</span></dt>
<dd><p class="first last">Whether to simplify the path by removing vertices
that do not affect its appearance.  If None, use the
<a class="reference internal" href="#matplotlib.path.Path.should_simplify" title="matplotlib.path.Path.should_simplify"><code class="xref py py-attr docutils literal notranslate"><span class="pre">should_simplify</span></code></a> attribute.  See also <code class="docutils literal notranslate"><a class="reference external" href="../tutorials/introductory/customizing.html?highlight=path.simplify#a-sample-matplotlibrc-file"><span class="pre">rcParams[&quot;path.simplify&quot;]</span> <span class="pre">=</span> <span class="pre">True</span></a></code>
and <code class="docutils literal notranslate"><a class="reference external" href="../tutorials/introductory/customizing.html?highlight=path.simplify_threshold#a-sample-matplotlibrc-file"><span class="pre">rcParams[&quot;path.simplify_threshold&quot;]</span> <span class="pre">=</span> <span class="pre">0.1111111111111111</span></a></code>.</p>
</dd>
<dt><strong>curves</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, curve segments will be returned as curve segments.
If False, all curves will be converted to line segments.</p>
</dd>
<dt><strong>sketch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or sequence, optional</span></dt>
<dd><p class="first last">If not None, must be a 3-tuple of the form
(scale, length, randomness), representing the sketch parameters.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.make_compound_path">
<em class="property">classmethod </em><code class="descname">make_compound_path</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.make_compound_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.make_compound_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a compound path from a list of Path objects.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.make_compound_path_from_polys">
<em class="property">classmethod </em><code class="descname">make_compound_path_from_polys</code><span class="sig-paren">(</span><em>XY</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.make_compound_path_from_polys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.make_compound_path_from_polys" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a compound path object to draw a number
of polygons with equal numbers of sides XY is a (numpolys x
numsides x 2) numpy array of vertices.  Return object is a
<a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a></p>
<p>(<a class="reference external" href="../gallery/misc/histogram_path.py">Source code</a>, <a class="reference external" href="../gallery/misc/histogram_path_00_00.png">png</a>, <a class="reference external" href="../gallery/misc/histogram_path_00_00.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/histogram_path_00_00.png" src="../_images/histogram_path_00_00.png" />
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#matplotlib.path.Path.readonly" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> if the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> is read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.should_simplify">
<code class="descname">should_simplify</code><a class="headerlink" href="#matplotlib.path.Path.should_simplify" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> if the vertices array should be simplified.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.simplify_threshold">
<code class="descname">simplify_threshold</code><a class="headerlink" href="#matplotlib.path.Path.simplify_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>The fraction of a pixel difference below which vertices will
be simplified out.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.to_polygons">
<code class="descname">to_polygons</code><span class="sig-paren">(</span><em>self</em>, <em>transform=None</em>, <em>width=0</em>, <em>height=0</em>, <em>closed_only=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.to_polygons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.to_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this path to a list of polygons or polylines.  Each
polygon/polyline is an Nx2 array of vertices.  In other words,
each polygon has no <code class="docutils literal notranslate"><span class="pre">MOVETO</span></code> instructions or curves.  This
is useful for displaying in backends that do not support
compound paths or Bezier curves.</p>
<p>If <em>width</em> and <em>height</em> are both non-zero then the lines will
be simplified so that vertices outside of (0, 0), (width,
height) will be clipped.</p>
<p>If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> (default), only closed polygons,
with the last point being the same as the first point, will be
returned.  Any unclosed polylines in the path will be
explicitly closed.  If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a>, any unclosed
polygons in the path will be returned as unclosed polygons,
and the closed polygons will be returned explicitly closed by
setting the last point to the same as the first point.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.transformed">
<code class="descname">transformed</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.transformed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.transformed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed copy of the path.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="transformations.html#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.transforms.TransformedPath</span></code></a></dt>
<dd>A specialized path class that will cache the transformed result and automatically update when the transform changes.</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_circle">
<em class="property">classmethod </em><code class="descname">unit_circle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_circle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the readonly <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> of the unit circle.</p>
<p>For most cases, <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code class="xref py py-func docutils literal notranslate"><span class="pre">Path.circle()</span></code></a> will be what you want.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_circle_righthalf">
<em class="property">classmethod </em><code class="descname">unit_circle_righthalf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_circle_righthalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_circle_righthalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> of the right half of a unit circle.</p>
<p>See <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path.circle</span></code></a> for the reference on the approximation used.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_rectangle">
<em class="property">classmethod </em><code class="descname">unit_rectangle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_rectangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> instance of the unit rectangle from (0, 0) to (1, 1).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_asterisk">
<em class="property">classmethod </em><code class="descname">unit_regular_asterisk</code><span class="sig-paren">(</span><em>numVertices</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_regular_asterisk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_regular_asterisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> for a unit regular asterisk with the given
numVertices and radius of 1.0, centered at (0, 0).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_polygon">
<em class="property">classmethod </em><code class="descname">unit_regular_polygon</code><span class="sig-paren">(</span><em>numVertices</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_regular_polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_regular_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance for a unit regular polygon with the
given <em>numVertices</em> and radius of 1.0, centered at (0, 0).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_star">
<em class="property">classmethod </em><code class="descname">unit_regular_star</code><span class="sig-paren">(</span><em>numVertices</em>, <em>innerCircle=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.unit_regular_star"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.unit_regular_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> for a unit regular star with the given
numVertices and radius of 1.0, centered at (0, 0).</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.vertices">
<code class="descname">vertices</code><a class="headerlink" href="#matplotlib.path.Path.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of vertices in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a> as an Nx2 numpy array.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.wedge">
<em class="property">classmethod </em><code class="descname">wedge</code><span class="sig-paren">(</span><em>theta1</em>, <em>theta2</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#Path.wedge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.Path.wedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit circle wedge from angles <em>theta1</em> to <em>theta2</em> (in
degrees).</p>
<p><em>theta2</em> is unwrapped to produce the shortest wedge within 360 degrees.
That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the wedge will be from <em>theta1</em>
to <em>theta2</em> - 360 and not a full circle plus some extra overlap.</p>
<p>If <em>n</em> is provided, it is the number of spline segments to make.
If <em>n</em> is not provided, the number of spline segments is
determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>
<p>See <a class="reference internal" href="#matplotlib.path.Path.arc" title="matplotlib.path.Path.arc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path.arc</span></code></a> for the reference on the approximation used.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.path.get_path_collection_extents">
<code class="descclassname">matplotlib.path.</code><code class="descname">get_path_collection_extents</code><span class="sig-paren">(</span><em>master_transform</em>, <em>paths</em>, <em>transforms</em>, <em>offsets</em>, <em>offset_transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#get_path_collection_extents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.get_path_collection_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a>s, <a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Transform</span></code></a>s objects, and offsets, as
found in a <a class="reference internal" href="collections_api.html#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PathCollection</span></code></a>, returns the bounding box that encapsulates
all of them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>master_transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Transform</span></code></a></span></dt>
<dd><p class="first last">Global transformation applied to all paths.</p>
</dd>
<dt><strong>paths</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Path</span></code></a></span></dt>
<dd></dd>
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="transformations.html#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Affine2D</span></code></a></span></dt>
<dd></dd>
<dt><strong>offsets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array-like</span></dt>
<dd></dd>
<dt><strong>offset_transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="transformations.html#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Affine2D</span></code></a></span></dt>
<dd><p class="first last">Transform applied to the offsets before offsetting the path.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The way that <em>paths</em>, <em>transforms</em> and <em>offsets</em> are combined
follows the same method as for collections:  Each is iterated over
independently, so if you have 3 paths, 2 transforms and 1 offset,
their combinations are as follows:</p>
<blockquote>
<div>(A, A, A), (B, B, A), (C, A, A)</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="matplotlib.path.get_paths_extents">
<code class="descclassname">matplotlib.path.</code><code class="descname">get_paths_extents</code><span class="sig-paren">(</span><em>paths</em>, <em>transforms=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/path.html#get_paths_extents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.path.get_paths_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>[<em>Deprecated</em>] Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> objects and optional
<a class="reference internal" href="transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a> objects, returns the
bounding box that encapsulates all of them.</p>
<p><em>paths</em> is a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instances.</p>
<p><em>transforms</em> is an optional sequence of
<a class="reference internal" href="transformations.html#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2D</span></code></a> instances to apply to
each path.</p>
<p class="rubric">Notes</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 3.1.</span></p>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Oct 19, 2019.
	Created using
	<a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
	Doc version v3.1.1-46-g54bb8d713.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
</footer>
</html>